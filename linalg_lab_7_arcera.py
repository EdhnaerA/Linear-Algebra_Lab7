# -*- coding: utf-8 -*-
"""LinAlg_Lab 7_Arcera.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XPXjbcKNEe3uALLGid66OScfZrKcYCNu

# **Arcera, Edhnaer**
## Laboratory 7 : Matrix Operations

# Task 1
Prove and implement the remaining 6 matrix multiplication properties. You may create your own matrices in which their shapes should not be lower than  (3,3) . In your methodology, create individual flowcharts for each property and discuss the property you would then present your proofs or validity of your implementation in the results section by comparing your result to present functions from NumPy

$$V1 = \begin{bmatrix}1&7&9\\1&3&1\\5&1&6\end{bmatrix}, V2 = \begin{bmatrix}2&6&9\\9&3&5\\8&3&6\end{bmatrix}$$

$$V1 = (V2*V3)=(V1*V2)V3$$

$$E*A\\ and \\ A*P= E*P$$
"""

import numpy as np


V1 = np.array([[1, 7, 9], [1, 3, 1], [5, 1, 6]])
V2 = np.array([[2, 6, 9], [9, 3, 5], [8, 3, 6]])
V3 = np.array([[6, 6, 6], [9, 4, 5], [5, 6, 2]])
V4 = np.identity(3)
V5 = np.zeros([3,3])



print("Shape of V1: ", V1.shape, "Shape of V2: ", V2.shape,"Shape of V3: ",
      V3.shape,"Shape of V4: ", V4.shape,"Shape of V5: ", V5.shape,)

Commutative_Property(V1, V2)
Associative_Property(V1, V2, V3)
Distributive_Property(V1, V2, V3)
Multiplicative_Identity_Property(V1, V4)
Multiplicative_Property_of_zero(V1, V5)
Dimension_Property(V1,V5)

def Commutative(M1, M2):
    V1V2 = np.dot(M1, M2)
    V2V1 = np.dot(M2, M1)
    print("Commutative Property" '\n')
    print("V1V2" '\n', V1V2)
    print("V2V1" '\n', V2V1)
    print("~" *64)

def Associative(M1, M2, M3):
    V2V3 = np.dot(M2, M3)
    V2V3V1 = np.dot(M1, V2V3)
    V1V2 = np.dot(M1, M2)
    V1V2V3 = np.dot(V1V2, M3)
    print("Associative Property" '\n')
    print("V1V2V3" '\n', V1V2V3)
    print("V2V3V1" '\n', V2V3V1)
    print("~" *64)


def Distributive(M1, M2, M3):
    V2V3 = np.add(M2, M3)
    V1V2V3 = np.dot(M1, V2V3)
    V1V2 = np.dot(M1, M2)
    V1V3 = np.dot(M1, M3)
    print("Distributive Property" '\n')
    print("V1V2V3")
    print(V1V2V3, '\n   =\n', V1V2 + V1V3)

    V2V3V1 = np.dot(V2, M1)
    V2V1 = np.dot(M2, M1)
    V3V1 = np.dot(M3, M1)
    print("V2V3V1")
    print(V2V3V1, '\n    =\n', V2V1 + V3V1)
    print("~" *64)


def Multiplicative_Identity(M1, MIP):
    print("Multiplicative Identity Property" '\n')
    Identity = np.dot(M1, MIP)
    print(Identity, '\n   =\n', M1)
    print("~" *64)


def zero(M1, Zero):
    print("Multiplicative Property of Zero" '\n')
    Z = np.dot(M1, Zero)
    print(Z, '\n   =\n', Zero)
    print("~" *64)


def Dimension(M1, M2):
  A = M1.shape[0]
  B = M2.shape[1]
  print(A, B)